import os
from manolo.base.wrappers.codecarbon import track_emissions
from manolo.base.utils.logger_utils import log_metrics

def codecarbon_init(cc_path, deactivate_codecarbon=False):
    """Set up variables for codecarbon."""
    os.environ["CODE_CARBON_FOLDER"] = cc_path
    if not os.path.exists(cc_path):
        os.makedirs(cc_path)

    if deactivate_codecarbon:
        os.environ["CODE_CARBON_ON"] = "False"
    else:
        os.environ["CODE_CARBON_ON"] = "True"

    "Still to implement a safeguard to make sure there is not an existin codecarbon.csv file"


def codecarbon_manolo(func):
    '''
    Decorator that applies codecarbon. 
    This also defines the arguments for the tracking_emmissions.
    
    By default the ouptu csv file will be "emissions_" followed by
    the name of the corresponding function.
    '''
    
    # Activate or deactivate codecarbon and then define output directory and file name.
    if os.environ["CODE_CARBON_ON"]=="True":
        file_name = f'emissions_{func.__name__}.csv'
        function = track_emissions(output_dir=os.environ["CODE_CARBON_FOLDER"], output_file=file_name)(func)

        # Wrapper that applies code after the decorated function is executed
        def wrapper_parse_and_clean(*args, **kwargs):
            result = function(*args, **kwargs)
            codecarbon_parser()
            codecarbon_cleaner(function.__name__)

            return result
    else:
        function = func
        # Simpler Wrapper - no need for parsing or remving files
        def wrapper_parse_and_clean(*args, **kwargs):
            return function(*args, **kwargs)

    return wrapper_parse_and_clean
    

def codecarbon_parser():
    '''
    Parses the metrics from codecarbon csv files to MLFlow. 
    The names assigned to each variable consisto of "emissions_" followed by the name
    of the function tracked followed by the name of the codecarbon metric.
    '''

    file_list = os.listdir(os.environ["CODE_CARBON_FOLDER"])
    print("Parsing files generated by codecarbon to MLFlow...")

    for codecarbon_file in file_list:
        codecarbon_path = os.path.join(os.environ["CODE_CARBON_FOLDER"], codecarbon_file)
        codecarbon_file_name = codecarbon_file.split('.')[0]
        if codecarbon_path.endswith('.csv'):
            with open(codecarbon_path, 'r') as f:
                param_name = f.readline()[:-1].split(',') # first row has the metrics names
                param_value = f.readline()[:-1].split(',') # second rows have the metric values

            log_codecarbon_as_metrics = {}
            log_codecarbon_as_param = {}

            for n, v in zip(param_name, param_value):
                try:
                    log_codecarbon_as_metrics[codecarbon_file_name + "_" + n] = eval(v)
                except:
                    # Non numeric values correspond to metadata from the experiment
                    log_codecarbon_as_param[codecarbon_file_name + "_" + n] = str(v)

            log_metrics(log_codecarbon_as_metrics)
            try:
                log_metrics(log_codecarbon_as_param, parameters=True)
            except:
                # Non numeric valuesonly need to be saved once at the beginning of the experiment.
                continue
                
def codecarbon_cleaner(func_name):
    '''
    Cleans the system and remove the files that codecarbon generated.
    '''
    print("Cleaning files generated by codecarbon...")
    os.remove(os.environ["CODE_CARBON_FOLDER"] + f'/emissions_{func_name}.csv')
    
